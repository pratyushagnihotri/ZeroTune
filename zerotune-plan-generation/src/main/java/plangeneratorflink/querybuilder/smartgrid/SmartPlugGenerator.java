package plangeneratorflink.querybuilder.smartgrid;

import plangeneratorflink.utils.DataTuple;
import plangeneratorflink.utils.RanGen;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

// ToDo: adapt following comment

/**
 * This class generates smart plug readings at fixed time intervals, storing them into a queue that
 * will be consumed by a {@link GeneratorSpout}.
 *
 * <p>The readings are generated by a separated thread and the interval resolutions is of seconds.
 * In order to increase the volume of readings you can decrease the interval down to 1 second. If
 * you need more data volume you will have to tune the other configuration parameters.
 *
 * <p>Configurations parameters:
 *
 * <p>- {@link Conf#GENERATOR_INTERVAL_SECONDS}: interval of record generation in seconds. - {@link
 * Conf#GENERATOR_NUM_HOUSES}: number of houses in the scenario. - {@link
 * Conf#GENERATOR_HOUSEHOLDS_MIN} and {@link Conf#GENERATOR_HOUSEHOLDS_MAX}: the range of number of
 * households within a house. - {@link Conf#GENERATOR_PLUGS_MIN} and {@link
 * Conf#GENERATOR_PLUGS_MAX}: the range of smart plugs within a household. - {@link
 * Conf#GENERATOR_LOADS}: a comma-separated list of peak loads that will be randomly assigned to
 * smart plugs. - {@link Conf#GENERATOR_LOAD_OSCILLATION}: by how much the peak load of the smart
 * plug will oscillate. - {@link Conf#GENERATOR_PROBABILITY_ON}: the probability of the smart plug
 * being on. - {@link Conf#GENERATOR_ON_LENGTHS}: a comma-separated list of lengths of time to be
 * selected from to set the amount of time that the smart plug will be on.
 *
 * <p>
 *
 * <p>From: http://corsi.dei.polimi.it/distsys/2013-2014/projects.html
 *
 * <p>Generates a dataset of a random set of smart plugs, each being part of a household, which is,
 * in turn, part of a house. Each smart plug records the actual load (in Watts) at each second. The
 * generated dataset is inspired by the DEBS 2014 challenge and follow a similar format, a sequence
 * of 6 comma separated values for each line (i.e., for each reading):
 *
 * <p>- a unique identifier of the measurement [64 bit unsigned integer value] - a timestamp of
 * measurement (number of seconds since January 1, 1970, 00:00:00 GMT) [64 bit unsigned integer
 * value] - a unique identifier (within a household) of the smart plug [32 bit unsigned integer
 * value] - a unique identifier of a household (within a house) where the plug is located [32 bit
 * unsigned integer value] - a unique identifier of a house where the household with the plug is
 * located [32 bit unsigned integer value] - the measurement [32 bit unsigned integer]
 *
 * @author Alessandro Sivieri
 * @author Maycon Viana Bordin <mayconbordin@gmail.com>
 */
public class SmartPlugGenerator implements Runnable, Serializable {
    // default config values
    private static final int HOUSES = 10;
    private static final int HOUSEHOLDS_MIN = 2;
    private static final int HOUSEHOLD_MAX = 10;
    private static final int PLUGS_MIN = 5;
    private static final int PLUGS_MAX = 20;
    private static final int LOADS[] = {25, 35, 50, 70, 150, 300, 600, 800, 900, 1200};
    private static final int OSCILLATION = 10;
    private static final double PROBABILITY_ON = 0.5D;
    private static final int LENGTHS[] = {600, 900, 1800, 3600, 5400, 7200, 0x1a5e0};

    private int currentId = 0; // originally this was typed as long

    private int interval;
    private int numHouses;
    private int householdMin;
    private int householdMax;
    private int plugsMin;
    private int plugsMax;
    private int[] loads;
    private int loadOscillation;
    private double probabilityOn;
    private int[] onLenghts;

    private HashMap<Integer, House> houses;
    private ScheduledExecutorService scheduler;
    private BlockingQueue<DataTuple> queue;

    public void initialize() {
        interval = 1;
        numHouses = HOUSES;
        householdMin = HOUSEHOLDS_MIN;
        householdMax = HOUSEHOLD_MAX;
        plugsMin = PLUGS_MIN;
        plugsMax = PLUGS_MAX;
        loads = LOADS;
        loadOscillation = OSCILLATION;
        probabilityOn = PROBABILITY_ON;
        onLenghts = LENGTHS;
        houses = new HashMap<>(numHouses);
        queue = new LinkedBlockingQueue<>();
        scheduler = Executors.newScheduledThreadPool(1);

        this.createScenario();
        ScheduledFuture<?> scheduledFuture =
                scheduler.scheduleAtFixedRate(this, 0, interval, TimeUnit.SECONDS);
        CompletableFuture.delayedExecutor(80, TimeUnit.SECONDS)
                .execute(
                        () -> {
                            scheduledFuture.cancel(true);
                            System.out.println("Cancel SmartPlugGenerator");
                        });
    }

    /**
     * Create {@link #numHouses} house instances, each with a random number of households between
     * {@link #householdMin} and {@link #householdMax}. Each household in its turn will have a
     * random number of smart plugs between {@link #plugsMin} and {@link #plugsMax}.
     */
    private void createScenario() {
        for (int i = 0; i < numHouses; ++i) {
            House house = new House(i);
            for (int j = 0; j < RanGen.randInt(householdMin, householdMax); ++j) {
                Household household = new Household(j);
                for (int k = 0; k < RanGen.randInt(plugsMin, plugsMax); ++k) {
                    SmartPlug sp =
                            new SmartPlug(
                                    k,
                                    loads[RanGen.randInt(0, loads.length - 1)],
                                    loadOscillation,
                                    probabilityOn,
                                    onLenghts);
                    household.addSmartPlug(sp);
                }
                house.addHousehold(household);
            }
            houses.put(i, house);
        }
    }

    @Override
    public void run() {
        long ts = (System.currentTimeMillis() / 1000) - interval;
        for (House house : houses.values()) {
            for (Household household : house.getHouseholds()) {
                for (SmartPlug plug : household.getPlugs()) {
                    plug.tryToSetOn(ts);

                    try {
                        queue.put(createDataTuple(ts, plug, household, house, 1));
                        queue.put(createDataTuple(ts, plug, household, house, 0));
                    } catch (InterruptedException ex) {
                        System.err.println(
                                "Something wrong happened while waiting to put record in the queue: "
                                        + ex);
                    }
                }
            }
        }
    }

    public DataTuple createDataTuple(
            long timestamp, SmartPlug plug, Household household, House house, Integer recordType) {
        ArrayList<Object> stringValues = new ArrayList<>();
        ArrayList<Object> integerValues = new ArrayList<>();
        ArrayList<Object> doubleValues = new ArrayList<>();

        integerValues.add(nextId()); // id
        integerValues.add(recordType); // ToDo: ? (recordtype)
        integerValues.add(plug.getId()); // smartplug id
        integerValues.add(household.getId()); // household id
        integerValues.add(house.getId()); // house id
        stringValues.add(String.valueOf(timestamp)); // timestamp
        if (recordType == 0) {
            doubleValues.add(plug.getLoad()); // smartplug load
        } else if (recordType == 1) {
            doubleValues.add(plug.getTotalLoadkWh()); // smartplug total load kWh
        }

        LinkedHashMap<Class<?>, ArrayList<Object>> tupleContent = new LinkedHashMap<>();
        tupleContent.put(String.class, stringValues);
        tupleContent.put(Integer.class, integerValues);
        tupleContent.put(Double.class, doubleValues);

        return new DataTuple(tupleContent, String.valueOf(timestamp));
    }

    public DataTuple generate() {
        try {
            DataTuple dt = queue.take();
            dt.replaceTimestamp(
                    String.valueOf(System.currentTimeMillis())); // reset timestamp for measurements
            return dt;
        } catch (InterruptedException ex) {
            System.err.println("Unable to get record from queue:" + ex);
        }
        return null;
    }

    private int nextId() {
        return currentId++;
    }
}
